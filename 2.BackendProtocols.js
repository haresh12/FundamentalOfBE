/**
 *  Protocol properties
 * 
 *    Data format (Text , Json , xml)
 *    Binory (grpc, RESP)
 * 
 *    Transfer Mode :  Message , stream
 * 
 *    Addressing System DNS , IP , MAC
 * 
 *    Directionality : Bi , uni
 * 
 *    State , Routing 
 */


/**
 *  OSI MODAL : OPEN SYSTEM INTERCONNECT  (MI STUFF IN THIS COURSE MAY NEED TO WATCH FEW TIMES)
 * 
 *   APPLICATION AND TRANSPORT THIS LAYERS MAY BE WE NEED TO LEARN MORE AS BE DEV
 * 
 *    Application
 *    Presentation
 *    Session
 *    Transport
 *    Network 
 *    Data Link
 *    Physical
 * 
 *    SEGMENT , PACKETS , FRAMES 
 * 
 *   firewall is nothing just stuff at network layor that allow application to stop sending some request overall blocking
 * 
 *    THINK ABOUT APPLICATIONS LIKE VPN FIREWALL THOSE ARE NOT REALLY APPLICATION LEVEL APPS THOSE BUILT ON NETWORK LAYER OR BELOW
 * 
 * 
 *    OSI VS TCP/IP LAYER
 */



/**
 *  INTERNET PROTOCOL : IP  (WATCH ONLY ONCE JUST GETTING BASIC IDEA TRY TO UNDERSTAND BECAUSE MOSTLY ITS ABOUT NETWORK LAYER)
 * 
 *   IP BUILDING BLOCKS
 * 
 *   ARE YOU IN MY SUBNET ? UNDERSTAND MORE ABOUT SUBNET
 * 
 *   IP PACKETS  HEADER AND DATA SECTION
 * 
 *   PACKET ME HOTA KYA KYA HAI => SOURCE IP ADDRESS =>> DATA =>>>> DESTINATION IP ADDRESS
 * 
 *   WHAT IS IP FRAGMENTATION ?
 * 
 * In networking, MTU, or Maximum Transmission Unit, refers to the largest size (in bytes) of a data packet that can be transmitted across a network interface without being fragmented. It's a crucial setting that impacts network performance and efficiency. 

    IP PROTOCOL ARE STATELSS 

      TIME OT LIVE , FRAGMENTATION , FLAGS , SOURCE IP , DESTINATION IP , DATA ALL THIS STUFF GOES WITH PACKET

     ECN ITS ALL ABOUT WHAT IP PACKET INCLUDE


     ICMP : INTERNET CONTROL MESSAGE PROTOCOL

     do ping google.com you will see all you have learnded like ttl frgament packet loss and all


     hareshlakhwani@Hareshs-Laptop FundamentalOfBE % traceroute google.com
traceroute to google.com (216.58.200.174), 64 hops max, 52 byte packets
 1  192.168.1.1 (192.168.1.1)  4.151 ms  2.526 ms  2.095 ms
 2  117.99.111.255 (117.99.111.255)  4.100 ms  9.026 ms  9.915 ms
 3  182.66.231.117 (182.66.231.117)  7.809 ms  5.501 ms  4.743 ms
 4  116.119.73.90 (116.119.73.90)  19.824 ms
    116.119.106.214 (116.119.106.214)  13.022 ms
    116.119.106.218 (116.119.106.218)  18.681 ms

  THIS GIVES INFO LIKE HOW MANY ROUTES IT HAS TO GO TO REACH GOOGLE.COM
 */


/**
 *   UDP :  USER DATAGRAM PROTOCOL ALL THESE PROTOCOL ARE ABOVE IP LAYER PROTOCOL
 * 
 *   VIDEO STREAMING
 *   VPN
 *   DNS 
 *   WEBRTC (REAL TIME COMMUNICATION)
 * 
 *   LEARNED THAT WEBRTC IS BUILT ON UDP AND TOTALLY DIFFERENT FROM WEBSOCKET
 * 
 *   SOURCE IP
 *   DESTINATION IP
 *   SOURCE PORT
 *   DESTINATION PORT
 *   SOURCE HOST 
 *   DESTINATION HOST
 *  
 *   STATLESSS
 * 
 *   WHAT IT CONTAINS SOURCE DESTINATION PORT LENTGHT OF DATA CHECKSUM AND DATA
 * 
 *   less security  , chances of data courrptions
 * 
 * 
 * Domain Name System (DNS) poisoning happens when fake information is entered into the cache of a domain name server, 
 * resulting in DNS queries producing an incorrect reply, sending users to the wrong website. DNS poisoning also goes by the terms 
 * “DNS spoofing” and “DNS cache poisoning.”

 */

/**
 *  VIDEO STREAMING
 *  WEBRTC
 *  DNS
 *  VPN 
 * 
 *  ALL THESE ARE GOOD OPTION FOR UDP
 */

/**
 *  UDP DATAGRAM 
 * 
 *  SOURCE AND DESTINATION PORT
 *  CHECKSUM
 *  DATA LENGTH
 */


/**
 *  simple protocol
 *  header size is small 8byte where in IP its 20
 *  stateless
 *  no handshake
 *  consistency vs letency => this one has low latency
 */

/**
 *  no acnoledgement
 *  no guarantee delievery
 *  anyone can send data and no order
 *  security spoofed
 */



/**
 *  TCP : TRANSPITION CONTROL PROTOCOL
 * 
 *   RELIEABLE COMMUNICATION
 *   ANY BIDRECTIONAL COMMUNICATION
 *   WEB COMMUNICATION
 *   DATABASE COMMUNICATION
 * 
 *   SOURCE IP PORT / DESTINATION IP PORT HASHED
 *  
 *   LOST PACKETS ARE RETRASMITTED
 * 
 *    SYN.  SYN/ACK SYN
 * 
 * 
 *   NEED DEEPER UNDERSTANDING ON FILE DESCRIPTOR
 * 
 *   NO NEEDED TO WAIT FOR ROUND TRIP TO COMPLETE
 * 
 *   WE CAN ACKNOLEDGE MULTIPLE SYN WITH WITH ACK BEST THINK I LEARNED TODAY
 * 
 *   RETRANSIMISION GIVES GUREENTED THAT SAGEMENT WILL BE RECIEVED
 * 
 *   layer 4 protocol 
 *   gurentee 
 *   stateful
 */


/**
 *  TCP SEGEMENT ITS ALL ABOUT WHAT GET PASSED 20 BYTES OF HEADER
 * 
 *  https://en.wikipedia.org/wiki/Jumbo_frame
 */



/**
 *   TSL. (TRANSPORT LAYER SECURITY)
 * 
 *    vanilla HTTP
 *    diffie hellman
 *    OVERALL PURPOSE IS TO ENCRYPT DATA WHAT THAT TRANSFERTED TO SENGMENT IN OSI LAYERS
 *    SYMMETRIC KEY ALGORITM
 *    AUTHENTICATE SERVER
 *    SNI
 *    PRESHARED 
 *    RSA PUBLIC PRIVATE CERTIFIT SHARING
 *    TLS 1.2 AND TLS 1.3
 *    X + Y + Z => Z CAN BE PUBLIC AND X AND Y PRIVATE DIFF HELLMAN ROCKS
 * 
 *   DIFFMAN >>>> RSA PUBLIC KEY >>>>> 1.3 >>>> 1.2 
 */



/**
 *  HTTP 1.1
 * 
 *   method  
 *   path 
 *   protocol
 *   headers
 *   body
 * 
 * 
 *  protocol
 *  code
 *  code text
 *  headers
 *  body
 * 
 *  REQUIRE HANDSHAKE BECAUSE BUILT ON TOP OF TCP
 *  FIRST TCP HANDSHAKE
 *  THEN TSL HANDSHAKE
 *  THEN HTTP STUFF STARTS
 * 
 *  http 1.1 keep alive is gift but still 6 crome limit is not good part
 * 
 *   host option was not there in 1.0 weird
 * 
 *  PERSISTABD CONNECTION
 *  LOW LATECY AND LOW CPU USAGE
 * 
 *  WHAT IS HTTP SMUGLING
 *  WHAT IS PIPLINING IN HTTP 1.1 ? OVERALL CLIENT IS ABLE TO SEND MULTIPLE REQUEST IS PIPLINING PREVIOUSLY ONE REQUEST AT TIME ONLY
 *  NO ONE USES PIPLELING IN HTTP 1.1 AND YES ITS WEIRD BECUASE IT WAITS FOR ORDERING 
 *  ALSO NEED TO UNDERSTAND HOW ONE IP CAN HOST 1000 HOST
 * 
 *  HTTP2
 *   
 *     SPDY
 *     COMPRESSION
 *     MULTIPLAXING NEED TO LEARN MORE
 *     SERVER PUSH (DEAD)
 *     SECURE (PROTOCOL OSSIFICATION)
 *  * 
 */



/**
 *    HTTPS AND NODE JS  AND TLS 
 * 
 *    HTTPS ======= HTTP + TLS (DIFF HELLMAN + RSA KEY TLS 1.2 OR 1.3 WHATEVER YOU SAY BUT S ADDED IN HTTPS BECAUSE WE ADDED THIS TLS LAYER IN OSI SESSION LAYER)
 * 
 *    ASYMTRIC ENCRIPTION IS TO COSTLY TO MUCH COMPUTE
 *  
 *  https://en.wikipedia.org/wiki/Advanced_Encryption_Standard
 * 
 *   SSL IS OLD NAME FOR TLS 
 * 
 *    CERTIFICATES : IT JUST CONTAIN PUBLIC KEY WITH METADATA SO WE DON'T ASK FOR PUBLIC KEY WE ASK FOR CERTIFICATE 
 */


/**
 *  WEB SOCKET
 * 
 *   BI-DIRECT COMMUNICATION  (LAYER 7 PROTOCOL REALLY ?)
 * 
 *   TCP DOES SO MUCH
 *   WE KEEP THE CONNECTION ALIVE
 *   WS OR WSS THESE PROTOCOL WE USE
 * 
 *    101 SWITCHING PROTOCOL FROM HTTP TO WS
 *    UPGRADE HEADER USED 
 * 
 *    CHATTING , 
 *    LIVE FEED  (I FEEL SERVER SIDE EVENTS MAKE MORE SENSE)
 *    
 * 
 *     FULL DUPLEX
 *     HTTP COMPETIBLE
 *     FIRWALL FRIENDLY
 * 
 *     PROXING IS TRICKY 
 * 
 *     SOME CONNECTION GET TERMINATED 
 * 
 *    WHAT IS PING PONG IN WS REALLY INTERSTING
 *    STATEFULL
 * 
 *    LONG POLLING IS KIND OF GOOD EXAMPLE OR ALTERNATIVE
 *    
 */


/**
 *  HTTP 2 (NEED TO SEE HOW ITS GOOD FROM 1 AND 1.1)
 *  1.1 STILL LEADS IN RACE (6 CONNECTION)
 * 
 *  REALLY SHOULD LEARN MORE ABOUT IT LIKE HOW IN SINGLE CONNECTION MULTIPLE REQUEST CAN GO
 *  ALSO WHATS THAT STREAM STUFF LIKE CLIENT SEND ODD NUMBER AND SERVER EVEN
 * 
 *  HTTP2 WITH PUSH (DEPRECATED)
 *  PREFECTH PRECONNECT ARE THOSE BAD IDEA
 * 
 *  SO STUFF THAT WE LEARNED ABOUT MULTIPLAXING IS POSSIBLE HERE IN HTTP2 AND THATS WHY IN SINGLE REQUEST
 *  WE ARE ABLE TO SEND MULTIPLE CONENCTION
 * 
 *  COMPRESSION IS BEST 
 * 
 *  SERVER PUSH
 * 
 *  SECURE BY DEFAULT BECAUSE OF DEFAULT AUTHENTICATION 
 * 
 *  TCP HEAD OF LINE BLOCKING (TCP ORDERING)
 * 
 *  SERVER PUSH NEVER PICKED UP
 * 
 *  HIGH CPU USAGE
 * 
 *  STREAM IS BEFFIFT BUT ISSUE ALSO BECAUSE OF ORDERING IN CASE OF MULTIPLE REQUEST
 * 
 *  MULTIPLAXING IS REASON MAINLY ITS FAST
 */


/**
 *  HTTP 3 QUIC (MULTIPLEXED STREAMS)
 * 
 *  now understood http2 blocking it real not good think thats why upd wins does not care about lossing packets speed matters
 *  HTTP USES QUIC
 *  QUIC HAS STREAMS
 *  QUIC USES UDP
 *  TLS IN ONE HANDSHAKE
 *  CONNECTION MIGRATION IS SOMETHING WE NEED TO GO DEEP
 *  HPACK COMPRESSION ALGORITHM for http2
 *  QPACK FROM HTTP3
 *  QUIC DOES NOT ALLOW FRAGMENTATION SO WHAT IF PACKET SIZE IS MORE THEN MTU SO USE SMALL DATAGRAM / SAGEMENT / FRAME / PACKETS
 */


/**
 *  GRPC =>>> HTTP2 KO AAGE BADANE KA KAAM
 */

/**
 *  WEB RTC
 * 
 *  NAT 
 *  STUN
 *  TURN 
 *  ICE
 *  SDP
 *  SINGLING THE SDP
 * 
 *  DEMO IS REALLY KILLER DIRECT CODE IN BROWSER
 * 
 *  connect through public interfaces
 *  find most optimal part
 *  subnet masking
 *  Network Address Transication
 */


/**
 *  MANY WAYS TO HTTPS SHORT VIDEOS 
 *  STYLE OF COMMUNICATION
 * 
 *  ESTABLISH CONNECTION
 *  ESTABLISH ENCRYPTION
 *  SEND DATA
 *  CLOSE CONNECTION
 * 
 *   HTTPS OVER TCP WITH TLS 1.2
 * 
 *   SEE ONE THINK WE NEED TO BE CLEAR ONE IS TCP CONNECTION ITS SIMPLE BUT IT DOES NOT INCLUDE ANYTHING REALATED TO SECURITY/ENCRIPTION STUFF
 *   AND FOR THAT ONLY WE HAVE TLS 1.2 1.3 client hello / server hello client fin / server fin OVERALL WE NEED TO UNDERSTAND IMPORTANCE OF 
 *   TLS NO MATTER ITS 1.2 1.3 OVERALL GOAL IS TO HELP WITH ENCRIPTION
 * 
 *   OVERALL DIFFERNT IF YOU SEE IN TLS 1.2 AND 1.3 IS IN 1.3 YOU HAVE ONE ROUND TRIP ONLY CLIENT HELLO / SERVER HELLO AND WE LEARNED ABOUT IT
 *   DIFF HELLMAN STUFF IN TLS LECTURE AND HOW ITS MORE SECURE OVERALL IT INCLUDE LOT OF MATHAMATICS BUT STILL CORE SHOULD BE CLEAR WHY TLS IS
 *   P1 AND THEN UNDERSTAND VERSION OF TLS ALSO 1.1 NO ONE USES IT
 * 
 *   ABOVE BOTH WHERE ON OVER TCP + TSL 
 * 
 *   BUT NOW LETS TALK ABOUT HTTPS OVER QUIC (HTTP3)
 *   EVERTHING IN SINGLE ROUND TRIP
 *   HERE EVERYTHING IS UDP
 * 
 *   WHAT IS TCP FAST OPEN
 *   
 *   0RTT HOW EVEN 0 ROUND TRIP IS POSSIBLE THAT ALSO IN TCP + TLS
 */


/**
 *  overall we are learning mainly three thing here
 * 
 *   first what are the ways client and server communication happens THIS IS MOST IMPORTENT
 *   REQEST/RESPONSE
 *   SHORT POLLING
 *   ASYC/SYNC
 *   LONG-POLLING
 *   SSE 
 *   PUSH
 *   WEBSOCKET
 *   PUB/SUB 
 *   STATELESS AND STATEFULL
 * 
 * 
 *  ONCE YOU HAVE IDEA ON THOSE STUFF NEXT GOES LITTLE MORE DEEPER ON UNDERSTAND DIFFERENT PROTOCOLS
 * 
 *      UNDERSTANDING OSI MODAL
 *      IP
 *      TCP
 *      UDP
 *      WEBSOCKET 
 *      HTTP 1.1 2 3
 *      TLS 1.2 / 1.3
 *      CERTIFICATES 
 *      QUIC
 *      WEBRTC
 *      GRPC GRPC GRPC GRPC GRPC STUFF THAT NEEDED TO BE LEARNED
 * 
 * 
 *  ONCE WE HAVE IDEA OF DIFFFERENT COMMUNICATION TYPES AND PROTOCOL NEXT WE ARE MOVING WITH BACKEND PATTERN
 * 
 *  OVERALL THESE THREE PARTS LIKE COMMUNICATION / PROTOCOL / PATTERN IS CORE OF THIS COURSE
 */


/**
 *  BACKEND EXECUTION PATTERN 
 * 
 *   PROCESS VS THREAD whats the difference 
 * 
 *    thread is just light weight process
 *    THREAD DOES NOT HAVE SPEPRATED MEMORY IT JUST SHARE WHATS PROCESS HAS SINGLE PROCESS CAN HAVE MULTIPLE THREAD (LWP)
 * 
 *   what is race condition in case of multi threading
 *   IN MOST OF CASES MULTI TRHEADING NOT REALLY GOOD IDEA 
 * 
 *   APACHED , ENVOY MULTI THREDING EXAMPLE
 * 
 *   SYC QUEUE AND ACCEPT QUEUE
 *   HASHING 
 *   PORT MATCHING
 * 
 *   https://www.cloudflare.com/learning/ddos/syn-flood-ddos-attack/
 * 
 *   KERNAL CREATES OVERALL 4 QUEUS
 *   SNY QUEUE
 *   ACCEPT QUEUE
 *   SEND BUFFERS (QUEUE)
 *   RECEIVE BUFFERS (QUEUE)  
 * 
 *   https://en.wikipedia.org/wiki/Zero-copy
 *   
 *   Nagles alogrithm
 * 
 *   THREE CORE PARTS AS BELOW KERNAL IS KILLER
 *   PROCESS AND THREAD
 *   SYN AND ACCEPT QUEUE
 *   SEND AND RECIEVE BUFFUR
 * 
 *   need to learn more what if recieve queue get fulled
 * 
 *   COMMUNICATION BETWEEN BE AND KERNAL IS WHAT WE LEARNED HERE
 * 
 *   LISNER 
 *   READER
 *   ACCEPTOR
 * 
 *  NODE HAS SINGLE LISNER READER AND ACCEPTOR ALL IN ONE THREAD
 * 
 *  SO_REUSEPORT LEARN MORE ABOUT
 * 
 *  NAGEL ALGORITHEM COULD BE ISSUE IN CLIENT DEALY REALLY GOOD VIDEO 
 *  why we have to wait until limit matches single big i need mean i need i don't need to wait 1460
 * 
 *   TCP_NODEALY
 * 
 *  https://github.com/curl/curl/blob/master/docs/libcurl/opts/CURLOPT_TCP_NODELAY.md
 * 
 *  https://curl.se/libcurl/c/CURLOPT_TCP_NODELAY.html
 */